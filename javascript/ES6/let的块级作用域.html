<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
 <div id="list"></div>
  <script>
    //let允许声明一个作用域被限制在块级中的变量,语句或表达式,而var声明的变量只能是是全局或者整个函数块的

    //作用域规则:let声明的变量只是在其声明的块或字子块中可使用,这一点,与var相似.二者最大的区别在于var声明的变量的作用域是全局或整个封闭函数

  /*  function varTest() {
      var x = 1;
      if (true) {
        var x = 2;  // 同样的变量!
        console.log(x);  // 2
      }
      console.log(x);  // 2
    }
    varTest();
    function letTest() {
      let x = 1;
      if (true) {
        let x = 2;  // 不同的变量
        console.log(x);  // 2
      }
      console.log(x);  // 1
    }
    letTest()*/

    var list = document.getElementById("list");

    for (let i = 1; i <= 5; i++) {
      var item = document.createElement("LI");
      item.appendChild(document.createTextNode("Item " + i));

      let j = i;
      item.onclick = function (ev) {
        console.log("Item " + j + " is clicked.");
      };
      list.appendChild(item);
    }
// 上面这段代码的意图是创建5个li,点击不同的li能够打印出当前li的序号。如果不用let，而改用var的话，将总是打印出 Item 5 is Clicked，因为 j 是函数级变量，5个内部函数都指向了同一个 j ,而 j 最后一次赋值是5。用了let后，j 变成块级域（也就是花括号中的块，每进入一次花括号就生成了一个块级域）,所以 5 个内部函数指向了不同的 j 。

//在程序或者函数的顶层，let并不会像var一样在全局对象上创造一个属性，比如

var x = 'global';
let y = 'global';
console.log(this.x); // "global"
console.log(this.y); // undefined
  </script>
</body>

</html>